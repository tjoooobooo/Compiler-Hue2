package mini_puck_c.backend

import CodeGenerator._
import RuntimeOrganisation.RTLocInfo
import mini_puck_c.linker.CU_NameManagement_C


/**
  * Instances of this class are used to create c code
  * for a single compilation unit (an object) from intermediate code.
  * The code generated will be "linked" with other code generated by other C_CodeBuilders that were called
  * for other compilation units.
  *
  * Code generation and "linking" have to assure that
  *  - local labels are unique, unless
  *  - they are exported / imported. In this case they have to be globally unique.
  *
  * The code generator's and the linkers part in this process is:
  * The code generator generates globally unique labels. The linker has to fix references to global names.
  */
class C_CodeBuilder extends CodeBuilder {

  private val RR: String = "RR" // name of return register
  private val SP: String = "SP" // name of stack pointer register
  private val FP: String = "FP" // name of frame pointer register
  private val SDA: String = "SDA" // name of the register thar contains the address of static data area


  // Create a C-specifiv unit to manage names (labels)
  private object NameManagement extends CU_NameManagement_C

  // the code buffer that is filled with target code.
  private val strBuf: StringBuilder = new StringBuilder


  // a string interpolation named 'c' is defined here.
  // It is used to format intermediate code instructions as C instructions.
  // See https://docs.scala-lang.org/overviews/core/string-interpolation.html

  // this method translates values and location of the intermediate code
  // to values and location of the C language.
  private def toC(arg: Any): String = arg match {
    case MIntProgLoc(locInfo) =>
      if (locInfo.nesting > 0) s"($FP.cellRef + ${locInfo.offset})->value"
      else s"($SDA.cellRef + ${locInfo.offset})->value"

    case MIntImmediateValue(d:Int) =>
      d.toString

    case TempMIntLoc(nr) =>
      s"T_$nr.value"

    case TempMAddressLoc(nr) =>
      s"(A_$nr.cellRef)"

    case MAddressProgLoc(locInfo) =>
      if (locInfo.nesting > 0) s"($FP.cellRef + ${locInfo.offset})->cellRef"
      else s"($SDA.cellRef + ${locInfo.offset})->cellRef"

    case DeRef(addrLoc) =>
      toC(addrLoc)+"->value"

    case MkRef(mIntLoc) =>
      mIntLoc match {
        case MIntProgLoc(locInfo: RTLocInfo) =>
          if (locInfo.nesting > 0) s"$FP.cellRef + ${locInfo.offset}"
          else s"$SDA.cellRef + ${locInfo.offset}"

        case DeRef(x) => toC(x)  // &*x  & and * cancel each other

        case TempMIntLoc(_) =>
          throw new Exception("internal error: trying to get the address of a temporary location")

      }

    case x => x.toString
  }

  // define string interpolation named c interpolation
  implicit private class CHelper(val sc: StringContext) {
    def c(args: Any*): String = {
      val pi = sc.parts.iterator
      val ai = args.iterator
      val bldr = new java.lang.StringBuilder(scala.StringContext.treatEscapes(pi.next()))
      while(pi.hasNext) {
        val part = scala.StringContext.treatEscapes(pi.next)
        val arg = toC(ai.next)
        bldr append arg
        bldr append part
      }
      bldr.toString
    }
  }





  /**
    * Format an instruction of the intermediate language as instructions of the C language.
    *
    * @param instr the intermediate code instruction that is to be translated to real code
    */
  def += (instr: IntermediateInstr): Unit = instr match {

    case AssignInstr(d, Some(op1), Some(op), Some(op2)) =>
      strBuf ++= c"\t$d = $op1 $op $op2;\n"

    case AssignInstr(d, Some(op1), None, None) =>
      strBuf ++= c"\t$d = $op1;\n"

    case AssignInstr(d, None, None, Some(op2)) =>
      strBuf ++= c"\t$d = $op2;\n"

    case WriteInstr(v) =>
      strBuf ++=  "\t" + c"""printf("%d\\n",$v);\n"""

    case AssignAddrInstr(dest, source) =>
      if (dest != source && c"$dest" != c"$source") // avoid assignment to itself
        strBuf ++= c"\t$dest = $source;\n"

    case IfInstr(operand1, op, operand2, jumpTo) =>
      strBuf ++= c"\tif ($operand1 $op $operand2) goto ${NameManagement.toLocal(jumpTo)};\n"

    case LabeledInstr(label) =>
      strBuf ++= c"${NameManagement.toLocal(label)} : \n"

    case ProcEntryInstr(procLabel: String) =>
      strBuf ++= c"${NameManagement.toGlobal(procLabel)} : \n"

    case JumpInstr(label) =>
      strBuf ++= c"\tgoto ${NameManagement.toLocal(label)};\n"

    case CallInstr(procLabel) =>
      strBuf ++= c"\tgoto ${NameManagement.toGlobal(procLabel)};\n"

    case ReturnInstr =>
      strBuf ++= c"\tgoto *RR;\n"

    case PushMIntInstr(t) =>
      strBuf ++= c"\t($SP.cellRef)->value = $t; ($SP.cellRef)--;\n"

    case PushMAddressInstr(a) =>
      strBuf ++= c"\t($SP.cellRef)->cellRef = $a; ($SP.cellRef)--;\n"

    case PushCodeAddrInstr(label) =>
      strBuf ++= c"\t$SP.cellRef->codeRef = &&${NameManagement.toLocal(label)}; ($SP.cellRef)--;\n"

    case PushFPInstr =>
      strBuf ++= c"\t$SP.cellRef->cellRef = $FP.cellRef; ($SP.cellRef)--;\n"

    case PopMIntInstr =>
      strBuf ++= c"\t($SP.cellRef)++;\n"

    case PopMAddressInstr =>
      strBuf ++= c"\t($SP.cellRef)++;\n"

    case PopCodeAddrToRRInstr =>
      strBuf ++= c"\t($SP.cellRef)++; $RR = $SP.cellRef->codeRef;\n"

    case PopFPInstr =>
      strBuf ++= c"\t($SP.cellRef)++; $FP.cellRef = $SP.cellRef->cellRef;\n"

    case StoreSPasFPInstr =>
      strBuf ++= c"\t$FP.cellRef = $SP.cellRef;\n"

    case AllocStaticInstr(size: Int) =>
      strBuf ++= c"\t // allocate static with size $size\n"

    case _ =>
      throw new Exception("internal error: unsupported format of intermediate instruction")
  }


  override def getCode: String = {
    val objectName = NameManagement.getCuName
    val usages : StringBuilder = new StringBuilder
    NameManagement.getDependencies.foreach( objectName =>
      usages ++= s".USE $objectName\n"
    )
    strBuf.insert(0, usages)
    strBuf.insert(0, s".OBJECT $objectName\n")
    strBuf.mkString
  }


  override def direct(directive: Directive): Unit = directive match {
    case ImportDirective(objectName, importedName) =>
      NameManagement.addImport(objectName, importedName)

    case ExportDirective(exportedName) =>
      NameManagement.addExport(exportedName)

    case CuNameDirective(cuName) =>
      NameManagement.setCuName(cuName)
  }

}
